#!/bin/bash
helpdoc(){
    cat <<EOF
Description:
	SCAPRUTE module: peak evaluating

Usage:
    scapture_mergesample [options]
    -h/---help  -- help information
    
Parameters passed from SCAPRUTE:
 -o          -- Prefix of output file
 --peak      -- list of evaluated peak files to merge 
                (one sample per line, split by tab,
                 1st col: "Sample_name",
                 2cd col: "PathofEvaluatedPeakFile" )
 --rawpeak   -- raw peak files to merge (Restricted by --peak)
 --path      -- path of scapture suite (ignore if scapture in PATH)
 --species   -- species for DeepPASS model ('human', 'mouse', 'rhesus', 'rat', 'zebrafish', 'fruitfly', 'worm')
 -g			 -- genome .fa file
 -h/---help  -- help information

Version: 2.0 2023/03/27

Author: Guo-Wei Li Email: liguowei@picb.ac.cn
Update by Pei-Hong Zhang 
EOF
}

if [ $# = 0 ]
then
    helpdoc
    exit 1
fi

PeakList="NULL"
RawPeakList="NULL"

ARGS=`getopt -o o:h:g: --long peak:,path:,rawpeak:,species:,help  -- "$@"`
eval set -- "$ARGS"
while true ; do
	case "$1" in
		-o) PREFIX=$2 ; shift 2;;
		--peak) PeakList=$2 ; shift 2;;
		--path) SCAPTUREPATH=$2 ; shift 2;;
		--rawpeak) RawPeakList=$2 ; shift 2;;
		--species) species=$2; shift 2;;
		-g) genome_fa=$2; shift 2;;
		-h) helpdoc ; exit 1;;
		--help) helpdoc ; exit 1;;
		--)
			shift
			break
			;;
		*) echo "unknown parameter:" $1; helpdoc; exit 1;;
	esac
done

if [ -z "$SCAPTUREPATH" ]; then
#	echo "scapture path is not set. Try to find scapture in current ENV"
	SCAPTUREPATH=$(which scapture)
	if [[ "$SCAPTUREPATH" == *scapture ]]; then
#		echo "scapture is found in: "$SCAPTUREPATH
		SCAPTUREPATH=${SCAPTUREPATH%scapture}
	else
		echo "scapture is not found!"
		exit 1
	fi
fi

#check parameters:
PeakFileList=""
if [[ "$PeakList" == "NULL" && "$RawPeakList" != "NULL" ]]; then
	PeakFileList=$RawPeakList
	if [ ! -e "$RawPeakList" ]; then echo "Raw peak list file dosn't exisits! exit !"; exit 1; fi;
elif [[ "$PeakList" != "NULL" && "$RawPeakList" == "NULL" ]]; then
	PeakFileList=$PeakList
	if [ ! -e "$PeakList" ]; then echo "Peak list file dosn't exisits! exit !"; exit 1; fi;
else
	echo "error in input peak list file parameter!"
	exit 1
fi


#Label sample in name field, then cat peaks from samples together
# PeakCombine=$(cat $PeakFileList | parallel -j 1 --colsep="\t" perl -alne \''$F[3]="$F[3]|{1}";$,="\t";print @F;'\' {2} | sort -k1,1 -k2,2n)
PeakCombine=$(cat $PeakFileList | parallel -j 1 --colsep="\t" perl -alne \''$F[3]="$F[3]|{1}|$F[1]|$F[2]";$,="\t";print @F;'\' {2}  | awk '{if($13 >0 || $14 == "positive") print }' | sort -k1,1 -k2,2n)
#extract center region (60%) of peaks to perform overlap analysis
PeakCentre=$( echo "$PeakCombine" | bedToGenePred /dev/stdin /dev/stdout | perl -alne '$r=0.6;  $ratio=int(1/((1-$r)/2)); $d=0;@s=split(",",$F[8]);@e=split(",",$F[9]); for($i=0;$i<$F[7];$i++){$d += ($e[$i]-$s[$i]);};    $startexon=0;$startdis=0;$dis = int($d/$ratio);for($i=0;$i<$F[7];$i++){ $dis -= ($e[$i]-$s[$i]); if($dis < 0){ $startdis = $e[$i] - $s[$i] + $dis; $startexon = $i+1; last;}; };   $endexon=$F[7]-1;$enddis=0;$dis = int($d/$ratio);for($i=$F[7]-1;$i>=0;$i--){ $dis -= ($e[$i]-$s[$i]); if($dis < 0){ $enddis = $e[$i] - $s[$i] + $dis; $endexon = $i + 1;last;}; };  $,="\t"; $s[$startexon-1] += $startdis; $e[$endexon-1] -= $enddis; print $F[0],$F[1],$F[2],$s[$startexon-1],$e[$endexon-1],$e[$endexon-1],$e[$endexon-1],$endexon-$startexon+1,join(",",@s[$startexon-1..$endexon-1]),join(",",@e[$startexon-1..$endexon-1]);' | genePredToBed /dev/stdin /dev/stdout)
echo "$PeakCentre" > $PREFIX".peakcenter.bed"

#assign identical ID to peaks with overlapped center region.
PeakCentrOverlap=$(bedtools intersect -a $PREFIX".peakcenter.bed" -b $PREFIX".peakcenter.bed" -s -split -f 0.6 -wao | perl -alne '@a=split(/\|/,$F[3]);@b=split(/\|/,$F[15]);next if $a[0] ne $b[0];print;' | sort -k2,2n -k14,14n -k4,4 -k16,16 | perl -alne 'BEGIN{$,="\t";$n=1;$m=0;}; $m++; $a=$F[3];$b=$F[15]; $g{$F[3]}=join("\t",@F[0..11]);$g{$F[15]}=join("\t",@F[12..23]); if($m==1){$c{$a}=$n;$c{$b}=$n;next;}; if( $c{$a} && $c{$b} ){ next; }; if( !$c{$a} && $c{$b} ){ $c{$a}=$c{$b};next; }; if( $c{$a} && !$c{$b} ){ $c{$b}=$c{$a};next; }; if( !$c{$a} && !$c{b} ){ $n++; $c{$a}=$n;$c{$b}=$n;next; };  END{for $k (keys %c){print $g{$k},$c{$k}};}' | sort -k13,13n -k1,1 -k2,2n)
PeakOverlap=$(echo "$PeakCentrOverlap" | perl -alne 'if($#ARGV==0){$g{$F[3]}=$F[12];}else{$,="\t";print @F,$g{$F[3]};}' - <(echo "$PeakCombine" ) | sort -k1,1 -k2,2n)
PeakOverlapNum=$(perl -alne 'if($#ARGV==0){$n{$F[$#F]}+=1;}else{$,="\t"; @a=split(/\|/,$F[3]); $F[3] = join("\|",@a[0..$#a-1]); print @F,$n{$F[$#F]};}' <(echo "$PeakOverlap") <(echo "$PeakOverlap") | sort -k1,1 -k2,2n)

if [[ "$PeakList" == "NULL" && "$RawPeakList" != "NULL" ]]; then
	#only output assigment of total peaks from all samples (raw peaks without evaluation)
	echo "$PeakOverlapNum" > $PREFIX".IntegratedSamples.bed"
	#echo $PREFIX".IntegratedSamples.bed"
elif [[ "$PeakList" != "NULL" && "$RawPeakList" == "NULL" ]]; then
	#echo "$PeakOverlapNum" > $PREFIX".IntegratedSamples.bed"
#	echo "$PeakCentrOverlap" > $PREFIX".IntegratedCentroverlaps.bed"
	#sort the order of peak with identical id (-k15,15n), then select peaks by priority of poly(a) database annotating (-k13,13nr) and then DeepPASS prediction (-k14,14r).
	# echo "$PeakOverlapNum" | sort -k15,15n -k13,13nr -k14,14r | perl -alne '$,="\t";print @F[0..$#F-2] unless $id{$F[$#F-1]}; $id{$F[$#F-1]}=1;' | sort -k1,1 -k2,2n > $PREFIX".Integrated.bed"
#	echo "$PeakOverlapNum" | sort -k16,16n -k13,13nr -k14,14r -u | sort -k16,16n -k13,13nr -k14,14r -k2,2n| awk 'BEGIN{site[0]=""; n=0; id=""}{if($16 != id) {if(n>0) {print site[int(n/2)+1]; n=1; site[n]=$0; id=$16}else{id=$16; n=1; site[n]=$0} } else{n=n+1; site[n]=$0} }END{print site[int(n/2)+1]}' | sort -k1,1 -k2,2n > $PREFIX".Integrated.bed"
	l=`echo "$PeakOverlapNum" | awk '{if(NF < 17 || length($15) != 200) print}' | wc -l`
	# echo $l
	if [ $l -gt 0 ]; then
		# echo 1
		echo "$PeakOverlapNum" | awk '{if((NF < 17 || length($15) != 200) && $3-$2 >= 300) {if($6 == "+") {start=$3-100; if(start < 0) start=0; print $1"\t"start"\t"$3+100"\t"$4"|"$3"\t0\t"$6} else{start=$2-100; if(start < 0) start=0; print $1"\t"start"\t"$2+100"\t"$4"|"$2"\t0\t"$6}}}' - | /picb/rnomics3/peihong/software/svr3/miniconda2/bin/bedtools getfasta -bed - -fi $genome_fa -s -name+ | paste - - |awk -v OFS="\t" 'NR==FNR{split($1, a, ">|:"); if(length($2) == 200) b[a[2]]=toupper($2)}NR!=FNR{if(NF < 17 && $6 == "-" && $4"|"$2 in b) {$14=$14"\t"b[$4"|"$2]; print} else if(NF < 17 && $6 == "+" && $4"|"$3 in b){$14=$14"\t"b[$4"|"$3]; print} else if(length($15) != 200 && $6 == "-" && $4"|"$2 in b) {$15=b[$4"|"$2]; print} else if(length($15) != 200 && $6 == "+" && $4"|"$3 in b) {$15=b[$4"|"$3]; print} }' - <(echo "$PeakOverlapNum") > $PREFIX".IntegratedSamples_tmp.bed"
		# head $PREFIX".IntegratedSamples_tmp.bed"
		# awk '{if(length($15) != 200) print}'  $PREFIX".IntegratedSamples_tmp.bed" | wc -l 
		# echo "$PeakOverlapNum" | awk '{if(length($15) != 200) {if($6 == "+") {start=$3-100; if(start < 0) start=0; print $1"\t"start"\t"$3+100"\t"$4"|"$3"\t0\t"$6} else{start=$2-100; if(start < 0) start=0; print $1"\t"start"\t"$2+100"\t"$4"|"$2"\t0\t"$6}}}' - | bedtools getfasta -bed - -fi $genome_fa -s -name+ | paste - - |awk 'NR==FNR{split($1, a, ">|:"); b[a[2]]=toupper($2)}NR!=FNR{if(length($15) != 200 && $6 == "-") {$15=b[$4"|"$2]; print} else if(length($15) != 200 && $6 == "+"){$15=b[$4"|"$3]; print}}' - <(echo "$PeakOverlapNum") >> $PREFIX".IntegratedSamples_tmp.bed"

		echo "$PeakOverlapNum" | awk '{if(NF == 17 && length($15) == 200 && $3-$2 >= 300) print}' | cat - $PREFIX".IntegratedSamples_tmp.bed" > $PREFIX".IntegratedSamples_tmp2.bed"
		rm $PREFIX".IntegratedSamples_tmp.bed"
	else
		echo "$PeakOverlapNum" > $PREFIX".IntegratedSamples_tmp2.bed"
	fi

	awk '{print $4"\t"$15}' $PREFIX".IntegratedSamples_tmp2.bed" > $PREFIX".IntegratedSamples.txt"

	check=`cat $PREFIX".IntegratedSamples.txt" | wc -l`
	if [ $check -eq 0 ]; then
		rm $PREFIX".IntegratedSamples_tmp2.bed"
		rm $PREFIX".peakcenter.bed"
		rm $PREFIX".IntegratedSamples.txt"
		exit 0
	fi

	${SCAPTUREPATH}/DeepPASS/Predict_value.py -m ${SCAPTUREPATH}/DeepPASS/${species}_best_model.h5 -p $PREFIX".IntegratedSamples.txt" -o ${PREFIX}_DeepPASS > ${PREFIX}_DeepPASS.log 2>&1 

	while [ ! -f ${PREFIX}_DeepPASS/Predict_Result.txt ]; do
		${SCAPTUREPATH}/DeepPASS/Predict_value.py -m ${SCAPTUREPATH}/DeepPASS/${species}_best_model.h5 -p $PREFIX".IntegratedSamples.txt" -o ${PREFIX}_DeepPASS > ${PREFIX}_DeepPASS.log 2>&1
	done
	awk 'NR==FNR{a[$1]=$3}NR!=FNR{if($4 in a) print $0"\t"a[$4]}' ${PREFIX}_DeepPASS/Predict_Result.txt $PREFIX".IntegratedSamples_tmp2.bed" | sort -k1,1 -k2,2n > $PREFIX".IntegratedSamples.bed"
	rm $PREFIX".IntegratedSamples_tmp2.bed"
	rm $PREFIX".IntegratedSamples.txt"
	rm -r ${PREFIX}_DeepPASS
	rm ${PREFIX}_DeepPASS.log
	# rm -r ${PREFIX}_DeepPASS

	cat $PREFIX".IntegratedSamples.bed" | awk -v OFS="\t" '{if($13 >= 2) $13 = 2; if($6 == "-") print}' |sort -k16,16n -k13,13nr -k18,18nr -k2,2nr | perl -alne '$,="\t";print @F[0..$#F-1] unless $id{$F[$#F-2]}; $id{$F[$#F-2]}=1;' | sort -k1,1 -k2,2n > $PREFIX".Integrated.bed"
	# cat $PREFIX".IntegratedSamples.bed" | awk -v OFS="\t" '{if($13 >= 2) $13 = 2; if($6 == "+") print}' |sort -k16,16n -k13,13nr -k14,14r -k3,3n| awk 'BEGIN{site[0]=""; n=0; id=""; level=0}{if($16 != id) {if(n>0) {print site[int(n/2)+1]; n=1; site[n]=$0; id=$16; level=$13}else{id=$16; n=1; site[n]=$0; level=$13} } else if($13 == level || $13 >= 2){n=n+1; site[n]=$0} }END{print site[int(n/2)+1]}' | sort -k1,1 -k2,2n >> $PREFIX".Integrated.bed"
    cat $PREFIX".IntegratedSamples.bed" | awk -v OFS="\t" '{if($13 >= 2) $13 = 2; if($6 == "+") print}' |sort -k16,16n -k13,13nr -k18,18nr -k2,2n| perl -alne '$,="\t";print @F[0..$#F-1] unless $id{$F[$#F-2]}; $id{$F[$#F-2]}=1;' | sort -k1,1 -k2,2n >> $PREFIX".Integrated.bed"
#	echo "$PeakOverlap" > $PREFIX".Integratedoverlaps.bed"
	# echo "$PeakOverlapNum" | awk '{if($6 == "-") print}' |sort -k16,16n -k13,13nr -k14,14r -k2,2nr | perl -alne '$,="\t";print unless $id{$F[$#F-1]}; $id{$F[$#F-1]}=1;' | sort -k1,1 -k2,2n > $PREFIX".Integrated.bed"
	# echo "$PeakOverlapNum" | awk '{if($6 == "+") print}' |sort -k16,16n -k13,13nr -k14,14r -k3,3n | perl -alne '$,="\t";print unless $id{$F[$#F-1]}; $id{$F[$#F-1]}=1;' | sort -k1,1 -k2,2n >> $PREFIX".Integrated.bed"

	
#	echo $PREFIX".IntegratedSamples.bed" $PREFIX".Integrated.bed"
else
	echo "error in input peak list file parameter!"
	unset PeakCombine PeakCentre PeakCentrOverlap PeakOverlap PeakOverlapNum
	rm $PREFIX".peakcenter.bed"
	exit 1
fi
#remove temp files
unset PeakCombine PeakCentre PeakCentrOverlap PeakOverlap PeakOverlapNum
rm $PREFIX".peakcenter.bed"
